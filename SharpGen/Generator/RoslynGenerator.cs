using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SharpGen.Model;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace SharpGen.Generator;

public sealed class RoslynGenerator
{
    private static readonly SyntaxTokenList ModuleInitModifiers = TokenList(Token(SyntaxKind.InternalKeyword), Token(SyntaxKind.StaticKeyword));
    private const string AutoGeneratedCommentText = "// <auto-generated/>\n";
    private static readonly AttributeListSyntax ModuleInitializerAttributeList = AttributeList(
        SingletonSeparatedList(Attribute(ParseName("System.Runtime.CompilerServices.ModuleInitializerAttribute")))
    );

    public void Run(CsAssembly csAssembly, string generatedCodeFolder, Ioc ioc)
    {
        if (string.IsNullOrEmpty(generatedCodeFolder))
            throw new ArgumentException("Value cannot be null or empty.", nameof(generatedCodeFolder));

        var logger = ioc.Logger;
        var generators = ioc.Generators;

        var directoryToCreate = new HashSet<string>(StringComparer.CurrentCulture);

        // Remove the generated directory before creating it
        if (!directoryToCreate.Contains(generatedCodeFolder))
        {
            directoryToCreate.Add(generatedCodeFolder);
            if (Directory.Exists(generatedCodeFolder))
            {
                foreach (var oldGeneratedFile in Directory.EnumerateFiles(generatedCodeFolder, "*.cs", SearchOption.AllDirectories))
                {
                    try
                    {
                        File.Delete(oldGeneratedFile);
                    }
                    catch
                    {
                        // ignored
                    }
                }
            }
        }

        if (!Directory.Exists(generatedCodeFolder))
            Directory.CreateDirectory(generatedCodeFolder);

        logger.Message("Process Assembly => {0}", generatedCodeFolder);

        List<SyntaxTree> trees = new()
        {
            CreateTree("Enumerations", ns => ns.Enums, generators.Enum),
            CreateTree("Structures", ns => ns.Structs, generators.Struct),
            CreateTree("Functions", ns => ns.Classes, generators.Group),
            CreateTree("Interfaces", ns => ns.Interfaces, generators.Interface)
        };

        var resultConstants = csAssembly.Namespaces
                                        .SelectMany(x => x.EnumerateDescendants<CsResultConstant>(withAdditionalItems: false))
                                        .ToArray();
        if (resultConstants.Length > 0)
            trees.Add(
                CSharpSyntaxTree.Create(
                    CompilationUnit(
                        default,
                        default,
                        default,
                        SingletonList<MemberDeclarationSyntax>(
                            ClassDeclaration("ModuleDataInitializer")
                               .WithModifiers(ModuleInitModifiers)
                               .AddMembers(GenerateResultDescriptor(resultConstants, ioc))
                        )
                    ).NormalizeWhitespace(elasticTrivia: true),
                    path: FormatFilePath("ModuleData")
                )
            );

        SyntaxTree CreateTree<T>(string fileName, Func<CsNamespace, IEnumerable<T>> membersFunc,
                                 IMemberCodeGenerator<T> generator) where T : CsBase
        {
            MemberDeclarationSyntax NamespaceSelector(CsNamespace ns)
            {
                MemberSyntaxList list = new(ioc);
                list.AddRange(membersFunc(ns).OrderBy(element => element.Name), generator);
                return NamespaceDeclaration(ParseName(ns.Name), default, default, List(list))
                   .WithLeadingTrivia(Comment(AutoGeneratedCommentText));
            }

            return CSharpSyntaxTree.Create(
                CompilationUnit(
                    default, default, default,
                    List(csAssembly.Namespaces.Select(NamespaceSelector))
                ).NormalizeWhitespace(elasticTrivia: true),
                path: FormatFilePath(fileName)
            );
        }

        string FormatFilePath(string fileName) => Path.Combine(generatedCodeFolder, $"{fileName}.cs");

        foreach (var tree in trees)
            File.WriteAllText(tree.FilePath, tree.GetCompilationUnitRoot().ToFullString());
    }

    private MethodDeclarationSyntax GenerateResultDescriptor(CsResultConstant[] descriptors, Ioc ioc)
    {
        StatementSyntaxList list = new(ioc);
        list.AddRange(descriptors, ioc.Generators.ResultRegistration);
        return MethodDeclaration(PredefinedType(Token(SyntaxKind.VoidKeyword)), "RegisterResultCodes")
              .WithModifiers(ModuleInitModifiers)
              .AddAttributeLists(ModuleInitializerAttributeList)
              .WithBody(list.ToBlock());
    }
}